//! The docstrings on types and their fields with `derive(Clap)` are displayed
//! in the CLI `--help`.

use anoma::cli::{ClientOpts, Gossip, InlinedClientOpts, Transfer};
use anoma::rpc::WorldClient;
use anoma::types::{Intent, Message, Transaction};
use clap::Clap;
use tendermint_rpc::{Client, HttpClient};

use std::{io, net::SocketAddr};
use tarpc::{client, context, tokio_serde::formats::Json};

pub async fn main() {
    match ClientOpts::parse() {
        ClientOpts::Inlined(ops) => exec_inlined(ops).await,
    }
}

async fn exec_inlined(ops: InlinedClientOpts) {
    match ops {
        InlinedClientOpts::Transfer(transaction) => transfer(transaction).await,
        InlinedClientOpts::Gossip(Gossip { orderbook, msg }) => {
            println!("calling gossip");
            let _res = gossip(orderbook, msg).await;
            println!("called gossip");
        }
    }
}

async fn transfer(Transfer { src, dest, amount }: Transfer) {
    // TODO add a counter
    let tx = Transaction { src, dest, amount };
    let mut tx_bytes = vec![];
    tx.encode(&mut tx_bytes).unwrap();
    let client =
        HttpClient::new("tcp://127.0.0.1:26657".parse().unwrap()).unwrap();
    // TODO broadcast_tx_commit shouldn't be used live
    let response = client.broadcast_tx_commit(tx_bytes.into()).await;
    println!("{:#?}", response);
}

async fn gossip(orderbook_addr: String, msg: String) -> io::Result<()> {
    println!("in gossip");
    let server_addr =
        orderbook_addr.parse::<SocketAddr>().unwrap_or_else(|e| {
            panic!(r#"--server_addr value "{}" invalid: {}"#, orderbook_addr, e)
        });

    let mut transport =
        tarpc::serde_transport::tcp::connect(server_addr, Json::default);
    transport.config_mut().max_frame_length(usize::MAX);

    // WorldClient is generated by the service attribute. It has a constructor `new` that takes a
    // config and any Transport as input.  let mut client =
    let mut client =
        WorldClient::new(client::Config::default(), transport.await?)
            .spawn()?;

    // The client has an RPC method for each RPC defined in the annotated trait. It takes the same
    // args as defined, with the addition of a Context, which is always the first arg. The Context
    // specifies a deadline and trace information which can be helpful in debugging requests.
    let hello = client.hello(context::current(), msg.clone()).await?;

    println!("msg send {} and received {}", msg, hello);

    Ok(())
}
