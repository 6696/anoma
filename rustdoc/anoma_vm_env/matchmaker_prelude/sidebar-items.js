initSidebarItems({"attr":[["matchmaker","This macro expects a function with signature:"]],"constant":[["BLOCK_HASH_LENGTH",""],["CHAIN_ID_LENGTH",""],["KEY_SEGMENT_SEPARATOR",""],["RESERVED_ADDRESS_PREFIX",""],["RESERVED_VP_KEY",""],["VP_KEY_PREFIX",""]],"derive":[["BorshDeserialize",""],["BorshSerialize",""]],"enum":[["Address",""],["DbKeySeg",""],["Error",""],["ImplicitAddress",""]],"fn":[["log_string","Log a string. The message will be printed at the `tracing::Level::Info`."],["remove_intents","Remove the intents from the matchmaker intent mempool, to call when they are fulfilled or outdated."],["send_match","Send a transaction with the `tx_data` and the `tx_code` to the ledger given in matchmaker parameters (`--tx-code-path` and `--ledger-address`)."],["update_data","Update the matchmaker state. This state will be pass on the next run of the matchmaker."]],"mod":[["address","Implements transparent addresses as described in Accounts Addresses."],["intent",""],["internal","Shared internal types between the host env and guest (wasm)."],["key",""],["slice","Slice management and manipulation."],["token","A basic fungible token"],["vm_memory","Memory types can be passed between the host and guest via wasm linear memory."]],"struct":[["BlockHash",""],["BlockHeight",""],["EstablishedAddress",""],["Key",""],["UpdateVp","A tx data type to update an accountâ€™s validity predicate"]],"trait":[["BorshDeserialize","A data-structure that can be de-serialized from binary format by NBOR."],["BorshSerialize","A data-structure that can be serialized into binary format by NBOR."],["KeySeg","Represents a segment in a path that may be used as a database key"]],"type":[["Result",""]]});